# 쉘 **정렬 (Shell Sort)**

버블 정렬은 작은 숫자가 배열의 앞부분의 숫자들을 비교하며 느리게 이동하여 정렬된다. 삽입 정렬도 마찬가지로 배열의 마지막 원소가 가장 작은 숫자라면 그 숫자가 배열의 맨 앞으로 이동해야 하므로 비효율적이라고 느껴질 수 있다.

**`쉘 정렬`은 이웃하는 원소의 숫자들끼리 자리를 이동함으로써 정렬이 이루어질 때 생길 수 있는 단점을 보완하기 위해서 삽입 정렬에서 배열 뒷부분의 숫자를 앞부분으로 빠르게 이동시키고 앞부분의 큰 숫자들은 뒷부분으로 이동시키며 가장 마지막에는 삽입 정렬을 수행**한다.

다음은 쉘 정렬을 통하여 정렬한 하나의 예시이다.

[30, 60, 90, 10, 40, 80, 40, 20, 10, 60, 50, 30, 40, 90, 80]

먼저 간격(gap)이 5가 되는 숫자끼리 그룹을 만든다. 숫자가 15개 있으므로 다음과 같이 그룹이 만들어질 수 있다.

![https://user-images.githubusercontent.com/63987872/166850769-cea54821-5880-4df7-8611-f41829fd3b81.png](https://user-images.githubusercontent.com/63987872/166850769-cea54821-5880-4df7-8611-f41829fd3b81.png)

[30, 80, 50], [60, 40, 30], [90, 20, 40], [10, 10, 90], [40, 60, 80]

각 그룹 내에서 정렬된 결과를 1줄로 나열하면 다음과 같다.

![https://user-images.githubusercontent.com/63987872/166850770-ffbcadf4-c636-4a71-aa08-24eb419b3d5e.png](https://user-images.githubusercontent.com/63987872/166850770-ffbcadf4-c636-4a71-aa08-24eb419b3d5e.png)

[30, 30, 20, 10, 40, 50, 40, 40, 10, 60, 80, 60, 90, 90, 80]

완전히 정렬된 상태는 아니지만, 전반적으로 큰 수가 뒤로 가고 작은 수가 앞으로 이동하였음을 확인할 수 있다.

이후, 간격을 5보다 작게 하여 또다시 그룹별로 삽입 정렬을 수행한다.

마지막 간격은 1로 하여 수행한다. 이는 삽입 정렬과 같다.

## 쉘 **정렬** 알고리즘

```
def shell_sort(A):
	# 입력: 배열 A
	# 출력: 정렬된 배열 A
	n = len(A)
	for each gap h = [h0 > h1 > ... > hk = 1]:
		for i = h to n - 1:
			CurrentElement = A[i]
			j = i
			while j >= h and A[j-h] > CurrentElement:
				A[j] = A[j - h]
				j = j - h
		A[j] = CurrentElement
	return A
```

아래와 같은 배열이 있다.

A = [30, 60, 90, 10, 40, 80, 40, 20, 10, 60, 50, 30, 40, 90, 80]

위 수도코드를 이 배열에 대해 삽입 정렬이 수행되는 과정은 다음과 같다.

- **[gap = 5]**
  i = 5, 6, 7, 8, 9일 때,
  ![https://user-images.githubusercontent.com/63987872/166850766-d9aa96b6-bdb0-408e-b01c-69f5ed83b9e1.png](https://user-images.githubusercontent.com/63987872/166850766-d9aa96b6-bdb0-408e-b01c-69f5ed83b9e1.png)
  i = 10, 11, 12, 13, 14일 때,
  ![https://user-images.githubusercontent.com/63987872/166850765-1aa7fa5d-fbba-42a6-a0dd-4148a3e383f2.png](https://user-images.githubusercontent.com/63987872/166850765-1aa7fa5d-fbba-42a6-a0dd-4148a3e383f2.png)
  각 그룹내에서 정렬된 결과를 1줄로 나열하면 다음과 같다.
  [30, 30, 20, 10, 40, 50, 40, 40, 10, 60, 80, 60, 90, 90, 80]
- **[gap = 3]**
  3개의 그룹으로 나누어지고 각 그룹의 원소의 개수는 5개다.
  ![https://user-images.githubusercontent.com/63987872/166850763-59e6a913-1651-49a9-89bb-f371d0d28381.png](https://user-images.githubusercontent.com/63987872/166850763-59e6a913-1651-49a9-89bb-f371d0d28381.png)
  각 그룹내에서 정렬된 결과를 1줄로 나열하면 다음과 같다.
  [10, 30, 10, 30, 40 , 20, 40, 40, 50, 60, 80, 60, 90, 90, 80]
- **[gap = 1]**
  [10, 10, 20, 30, 30, 40, 40, 40, 50, 60, 60, 80, 80, 90, 90]

쉘 정렬의 성능은 간격 선정에 따라서 좌우된다. 지금까지 알려진 가장 좋은 성능을 보이는 간격은 1, 4, 10, 23, 57, 132, 301, 701이다.

## 구현

[쉘 정렬](shell_sort.py)
